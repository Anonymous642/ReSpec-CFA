/*
 * huffman.c
 *
 * Created on: Oct 7, 2024
 */

#include "huffman.h"
#include "cfa_engine.h"

int HUFFMAN_TABLE[256] = {
		0x0,
		0x7d,
		0x3,
		0x1e,
		0x3f,
		0x28,
		0x29,
		0x2a,
		0x7c2e,
		0x7c2f,
		0x7c30,
		0x7c31,
		0x7c32,
		0x7c33,
		0x7c34,
		0x7c35,
		0x7c36,
		0x6,
		0x7c37,
		0x7c38,
		0x2b,
		0x7c39,
		0x7c3a,
		0x7c3b,
		0x2c,
		0x7c3c,
		0x7c3d,
		0x7c3e,
		0x7c3f,
		0x7c40,
		0x7c41,
		0x7c42,
		0x7c43,
		0x7c44,
		0x2d,
		0x7c45,
		0x7c46,
		0x7c47,
		0x2e,
		0x7c48,
		0x2f,
		0x7c49,
		0x7c4a,
		0x7c4b,
		0x7c4c,
		0x7c4d,
		0x7c4e,
		0x7c4f,
		0x7c50,
		0x7c51,
		0x7c52,
		0x10,
		0x7c53,
		0x7c54,
		0x7c55,
		0x7c56,
		0x7c57,
		0x7c58,
		0x7c59,
		0x7c5a,
		0x7c5b,
		0x7c5c,
		0x7c5d,
		0x7c5e,
		0x7c5f,
		0x7c60,
		0x7c61,
		0x7c62,
		0x7c63,
		0x7c64,
		0x7c65,
		0x7c66,
		0x7c67,
		0x7c68,
		0x7c69,
		0x7c6a,
		0x7c6b,
		0x7c6c,
		0x7c6d,
		0x7c6e,
		0x7c6f,
		0x7c70,
		0x7c71,
		0x7c72,
		0x7c73,
		0x7c74,
		0x7c75,
		0x7c76,
		0x38,
		0x7c77,
		0x7c78,
		0x7c79,
		0x7c7a,
		0x7c7b,
		0x7c7c,
		0x7c7d,
		0x7c7e,
		0x7c7f,
		0x7c80,
		0x7c81,
		0x7c82,
		0x7c83,
		0x7c84,
		0x7c85,
		0x7c86,
		0x7c87,
		0x7c88,
		0x7c89,
		0x7c8a,
		0x7c8b,
		0x7c8c,
		0x7c8d,
		0x7c8e,
		0x7c8f,
		0x7c90,
		0x7c91,
		0x7c92,
		0x7c93,
		0x7c94,
		0x7c95,
		0x7c96,
		0x7c97,
		0x7c98,
		0x7c99,
		0x7c9a,
		0x7c9b,
		0x7c9c,
		0x7c9d,
		0x7c9e,
		0x7c9f,
		0x7ca0,
		0x7ca1,
		0x7ca2,
		0x7ca3,
		0x7ca4,
		0x7ca5,
		0x7ca6,
		0x7ca7,
		0x7ca8,
		0x7ca9,
		0x7caa,
		0x7cab,
		0x7cac,
		0x7cad,
		0x7cae,
		0x7caf,
		0x7cb0,
		0x7cb1,
		0x7cb2,
		0x7cb3,
		0x7cb4,
		0x7cb5,
		0x7cb6,
		0x7cb7,
		0x7cb8,
		0x7cb9,
		0x7cba,
		0x7cbb,
		0x7cbc,
		0x7cbd,
		0x7cbe,
		0x7cbf,
		0x7cc0,
		0x7cc1,
		0x39,
		0x7cc2,
		0x7cc3,
		0x7cc4,
		0x7cc5,
		0x7cc6,
		0x7cc7,
		0x7cc8,
		0x7cc9,
		0x7cca,
		0x11,
		0x7ccb,
		0x7ccc,
		0x7ccd,
		0x7cce,
		0x7ccf,
		0x7cd0,
		0x7cd1,
		0x7cd2,
		0x7cd3,
		0x7cd4,
		0x7cd5,
		0x7cd6,
		0x7cd7,
		0x7cd8,
		0x7cd9,
		0x7cda,
		0x7cdb,
		0x7cdc,
		0x7cdd,
		0x7cde,
		0x7cdf,
		0x7ce0,
		0x7ce1,
		0x7ce2,
		0x7ce3,
		0x7ce4,
		0x7ce5,
		0x7ce6,
		0x7ce7,
		0x7ce8,
		0x7ce9,
		0x7cea,
		0x7ceb,
		0x12,
		0x7cec,
		0x7ced,
		0x7cee,
		0x7cef,
		0x7cf0,
		0x7cf1,
		0x7cf2,
		0x7cf3,
		0x7cf4,
		0x7cf5,
		0x7cf6,
		0x7cf7,
		0x7cf8,
		0x3a,
		0x7cf9,
		0x7cfa,
		0x7cfb,
		0x7cfc,
		0x7cfd,
		0x7cfe,
		0x7cff,
		0x3e00,
		0x3e01,
		0x3e02,
		0x3e03,
		0x3e04,
		0x3e05,
		0x3e06,
		0x3e07,
		0x3e08,
		0x3e09,
		0x3e0a,
		0x3e0b,
		0x3e0c,
		0x3e0d,
		0x3e0e,
		0x3e0f,
		0x3e10,
		0x3e11,
		0x3e12,
		0x3e13,
		0x3b,
		0x3e14,
		0x3e15,
		0x3e16,
		0x13,
		0x2,
};

uint8_t HUFFMAN_LENGTHS[256] = {
		2,
		7,
		3,
		5,
		6,
		6,
		6,
		6,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		3,
		15,
		15,
		6,
		15,
		15,
		15,
		6,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		6,
		15,
		15,
		15,
		6,
		15,
		6,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		5,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		6,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		6,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		5,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		5,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		6,
		15,
		15,
		15,
		15,
		15,
		15,
		15,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		14,
		6,
		14,
		14,
		14,
		5,
		3,
};


uint8_t temp_buffer[24];
uint32_t encoded_byte;
uint32_t code;
uint8_t length;
short bits_left_local;
int shift_amount;
uint32_t mask;
uint32_t selected_bits;
int safety_save;
void huffman_start(){
	encoded_byte = 0;
}

int huffman(CFA_REPORT * report_secure, uint8_t * to_log, int original_size, int speculating){

	// Huffman encode each byte
	int encoded_size = 0;

	bits_left_local = report_secure -> bits_left; // sanity check to ensure the modules stay synced
	
        /*
        As huffman codes work on bits, a subpath may begin in the middle of a byte. Thus if the value being encoded
          is a subpath-ID (or repeat count) we need to copy the correct bits out of the log before replacing the subpath
          with its encoded ID. Also note that if the subpath occurs as the first entry to a new log (safety_save > MAX_LOG_SIZE)
          we do no need to copy any values out of the log
        */
        if(speculating == 1 && safety_save <= MAX_LOG_SIZE_BYTES){
		for(int j=0; j<8-bits_left_local; j++){
		    mask = 0x00000080 | (mask >> 1);
		}
		encoded_byte = report_secure->CFLog[report_secure->num_CF_Log_size] & mask;
		encoded_byte = encoded_byte << 24;
		mask = 0;
	}

	for(int i=original_size-1; i>-1; i--){
		// Fetch encoding
		code = HUFFMAN_TABLE[to_log[i]];
		length = HUFFMAN_LENGTHS[to_log[i]];
		code = code << (32-length);


		// encode the byte
	    while(length > 0){

	    	// Determine how many bits to move
	        if (length >= bits_left_local){
	        	shift_amount = bits_left_local;
	        }else{
	        	shift_amount = length;
	        }

	        for(int j=0; j<shift_amount; j++){
	        	mask = 0x80000000 | (mask >> 1);
	        }

	        selected_bits = mask & code;
	        mask = 0;
	        code = code << shift_amount;
	        length = length - shift_amount;

	        selected_bits = selected_bits >> (8-bits_left_local);
	        encoded_byte = encoded_byte | selected_bits;
	        bits_left_local = bits_left_local - shift_amount;
	        if (bits_left_local == 0){
	        	temp_buffer[encoded_size] = ((uint8_t*) &encoded_byte)[3];
	        	encoded_size++;
	        	encoded_byte = 0;
	        	bits_left_local = 8;
	        }
	    }
	}

	/*
        Any remaining encoded bits are written to the end of the log to ensure that any trailing huffman bits are sent 
          to the verifier in the final log
        */
	safety_save = report_secure->num_CF_Log_size + encoded_size;
	if(!(safety_save > MAX_LOG_SIZE_BYTES+1)){
	    report_secure->CFLog[report_secure->num_CF_Log_size + encoded_size] = ((uint8_t*) &encoded_byte)[3];
	}
	report_secure -> bits_left = bits_left_local;
	for(int i=0; i<encoded_size; i++){
		to_log[i] = temp_buffer[(encoded_size-1)-i];
	}
	return encoded_size;
}

